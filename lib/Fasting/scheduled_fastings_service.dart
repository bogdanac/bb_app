import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'fasting_utils.dart';
import '../Services/firebase_backup_service.dart';
import '../Notifications/notification_service.dart';

class ScheduledFastingsService {
  static const String _scheduledFastingsKey = 'scheduled_fastings';

  // Dr. Pelz cycle-based fasting rules (when menstrual scheduling is enabled):
  // - 36h monthly: Start Day 6-7 (follicular, estrogen rising)
  // - 48h quarterly: Start Day 7 ONLY (max buffer from menstruation & ovulation)
  // - 72h biannual: Start Day 7 ONLY (widest safety margin)
  // - 24h weekly: Day 4-10 (follicular) OR Day 15-17 (early luteal) ONLY
  // - After 48h/72h fast: Skip next weekly fast (recovery week, max 14h IF)
  // - Avoid fasting: Days 1-3 (menstruation), Days 12-14 (ovulation peak), Day 20+ (late luteal)

  /// Get all scheduled fastings
  static Future<List<ScheduledFasting>> getScheduledFastings() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_scheduledFastingsKey);
    
    if (jsonString == null) {
      // Generate default schedule for next 2 months
      return await generateDefaultSchedule();
    }

    final List<dynamic> jsonList = jsonDecode(jsonString);
    return jsonList.map((json) => ScheduledFasting.fromJson(json)).toList();
  }

  /// Save scheduled fastings
  static Future<void> saveScheduledFastings(List<ScheduledFasting> fastings) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = jsonEncode(fastings.map((f) => f.toJson()).toList());
    await prefs.setString(_scheduledFastingsKey, jsonString);

    // Schedule 72h prep reminder for upcoming water fasts
    await _schedule72hPrepReminders(fastings);

    // Backup to Firebase
    FirebaseBackupService.triggerBackup();
  }

  /// Schedule prep reminders for 72h water fasts (3 days before)
  static Future<void> _schedule72hPrepReminders(List<ScheduledFasting> fastings) async {
    final notificationService = NotificationService();
    final now = DateTime.now();

    // Find the next upcoming 72h water fast
    final upcoming72hFasts = fastings
        .where((f) =>
            f.fastType == FastingUtils.waterFast &&
            f.isEnabled &&
            f.date.isAfter(now))
        .toList()
      ..sort((a, b) => a.date.compareTo(b.date));

    if (upcoming72hFasts.isNotEmpty) {
      // Schedule prep reminder for the next 72h fast
      await notificationService.schedule72hPrepReminderNotification(
        fastDate: upcoming72hFasts.first.date,
      );
    } else {
      // No upcoming 72h fasts, cancel any existing reminder
      await notificationService.cancel72hPrepReminderNotification();
    }
  }

  /// Generate default schedule based on preferred day and scheduling mode (fixed day or menstrual)
  static Future<List<ScheduledFasting>> generateDefaultSchedule() async {
    final List<ScheduledFasting> schedule = [];
    final now = DateTime.now();
    final endDate = DateTime(now.year, now.month + 2, now.day);

    // Get preferred fasting days from settings
    final prefs = await SharedPreferences.getInstance();
    final preferredDay = prefs.getInt('preferred_fasting_day') ?? 5; // Default to Friday
    final preferredMonthlyDay = prefs.getInt('preferred_monthly_fasting_day') ?? 25; // Default to 25th
    final useMenstrualScheduling = prefs.getBool('fasting_use_menstrual_scheduling') ?? false;

    // If menstrual scheduling is enabled, use Dr. Pelz's cycle-based protocol
    if (useMenstrualScheduling) {
      return await _generateCycleBasedSchedule(prefs, now, endDate, preferredDay);
    }

    // Otherwise use fixed-day scheduling (original logic)
    DateTime current = DateTime(now.year, now.month, now.day - 3); // Start from 3 days ago for grace period
    DateTime? lastFastEnd; // Track when the last fast ends

    while (current.isBefore(endDate)) {
      final isPreferredDay = current.weekday == preferredDay;
      final isLongFastDay = current.day == preferredMonthlyDay;

      if (isPreferredDay || isLongFastDay) {
        // Check if we need to skip this date due to ongoing fast
        if (lastFastEnd != null && current.isBefore(lastFastEnd)) {
          current = current.add(const Duration(days: 1));
          continue; // Skip this date as we're still in a previous fast
        }

        final (fastType, shouldSkipPreferredDay) = _getSmartFastTypeForDate(
          current, isPreferredDay, isLongFastDay, schedule, preferredDay, preferredMonthlyDay,
          useMenstrualScheduling: false,
        );

        if (fastType.isNotEmpty) {
          final newFast = ScheduledFasting(
            id: '${current.millisecondsSinceEpoch}',
            date: current,
            fastType: fastType,
            isEnabled: true,
            isAutoGenerated: true,
            isEstimate: false,
          );

          schedule.add(newFast);

          // Update lastFastEnd to prevent overlaps
          lastFastEnd = current.add(newFast.duration);

          // If we scheduled a long fast that covers preferred day, mark it to skip preferred day
          if (isLongFastDay && shouldSkipPreferredDay) {
            // Find and remove any preferred day fast that would overlap
            schedule.removeWhere((fast) =>
              fast.date.isAfter(current) &&
              fast.date.isBefore(lastFastEnd!) &&
              fast.date.weekday == preferredDay
            );
          }
        }
      }

      current = current.add(const Duration(days: 1));
    }

    await saveScheduledFastings(schedule);
    return schedule;
  }

  /// Generate cycle-based schedule following Dr. Pelz's protocol
  /// Rules:
  /// - Long fasts (36h/48h/72h): Start on user-selected cycle day (default Day 7)
  /// - Weekly 24h: Only on Days 4-10 (follicular) or Days 15-17 (early luteal)
  /// - Skip weekly fast the week after a 48h or 72h fast (recovery)
  /// - No fasting Days 1-3, 12-14, 20+
  static Future<List<ScheduledFasting>> _generateCycleBasedSchedule(
    SharedPreferences prefs,
    DateTime now,
    DateTime endDate,
    int preferredWeekday,
  ) async {
    final List<ScheduledFasting> schedule = [];

    // Get cycle data
    final lastPeriodStartStr = prefs.getString('last_period_start');
    final averageCycleLength = prefs.getInt('average_cycle_length') ?? 28;
    final longFastCycleDay = prefs.getInt('fasting_long_fast_cycle_day') ?? 7; // Default Day 7

    if (lastPeriodStartStr == null) {
      // No period data - fall back to fixed scheduling
      return schedule;
    }

    final lastPeriodStart = DateTime.parse(lastPeriodStartStr);
    final startDate = DateTime(now.year, now.month, now.day - 3);

    // Find all cycle starts within our date range
    List<DateTime> cycleStarts = [];
    DateTime periodStart = lastPeriodStart;

    // Go back to find cycles that might overlap with our range
    while (periodStart.isAfter(startDate.subtract(Duration(days: averageCycleLength)))) {
      periodStart = periodStart.subtract(Duration(days: averageCycleLength));
    }

    // Collect cycle starts
    while (periodStart.isBefore(endDate)) {
      if (periodStart.isAfter(startDate.subtract(Duration(days: averageCycleLength)))) {
        cycleStarts.add(DateTime(periodStart.year, periodStart.month, periodStart.day));
      }
      periodStart = periodStart.add(Duration(days: averageCycleLength));
    }

    // Track recovery weeks (skip weekly fast after 48h/72h)
    Set<DateTime> recoveryWeekStarts = {};

    // First pass: Schedule long fasts on user-selected cycle day
    for (int i = 0; i < cycleStarts.length; i++) {
      final cycleStart = cycleStarts[i];
      final longFastDate = cycleStart.add(Duration(days: longFastCycleDay - 1)); // Convert to 0-indexed

      if (longFastDate.isBefore(startDate) || longFastDate.isAfter(endDate)) continue;

      // Determine long fast type based on timing
      final String longFastType;
      final month = longFastDate.month;

      // 72h: January and September (twice per year)
      if (month == 1 || month == 9) {
        longFastType = FastingUtils.waterFast;
        // Add recovery week after 72h fast
        final recoveryWeekStart = longFastDate.add(const Duration(days: 7));
        recoveryWeekStarts.add(DateTime(recoveryWeekStart.year, recoveryWeekStart.month, recoveryWeekStart.day));
      }
      // 48h: Quarterly (April, July, October) - months that aren't 72h months
      else if (month == 4 || month == 7 || month == 10) {
        longFastType = FastingUtils.quarterlyFast;
        // Add recovery week after 48h fast
        final recoveryWeekStart = longFastDate.add(const Duration(days: 7));
        recoveryWeekStarts.add(DateTime(recoveryWeekStart.year, recoveryWeekStart.month, recoveryWeekStart.day));
      }
      // 36h: All other months
      else {
        longFastType = FastingUtils.monthlyFast;
      }

      schedule.add(ScheduledFasting(
        id: '${longFastDate.millisecondsSinceEpoch}',
        date: longFastDate,
        fastType: longFastType,
        isEnabled: true,
        isAutoGenerated: true,
        isEstimate: true, // Cycle-based dates are estimates
        notes: 'Day $longFastCycleDay of cycle - ${_getLongFastName(longFastType)}',
      ));
    }

    // Second pass: Schedule weekly fasts on safe days
    // Safe days: 4-10 (follicular) or 15-17 (early luteal)
    DateTime current = startDate;
    while (current.isBefore(endDate)) {
      // Check if this is the preferred weekday
      if (current.weekday == preferredWeekday) {
        // Find which cycle this date belongs to
        final cycleDay = _getCycleDayForDate(current, cycleStarts, averageCycleLength);

        if (cycleDay != null) {
          // Check if this is a safe day for 24h fast
          final isSafeFollicular = cycleDay >= 4 && cycleDay <= 10;
          final isSafeEarlyLuteal = cycleDay >= 15 && cycleDay <= 17;

          // Check if we're in a recovery week
          final isRecoveryWeek = _isInRecoveryWeek(current, recoveryWeekStarts);

          // Check if there's already a long fast scheduled within 3 days
          final hasNearbyLongFast = schedule.any((f) =>
            f.fastType != FastingUtils.weeklyFast &&
            (f.date.difference(current).inDays.abs() <= 3)
          );

          if ((isSafeFollicular || isSafeEarlyLuteal) && !isRecoveryWeek && !hasNearbyLongFast) {
            schedule.add(ScheduledFasting(
              id: '${current.millisecondsSinceEpoch}',
              date: current,
              fastType: FastingUtils.weeklyFast,
              isEnabled: true,
              isAutoGenerated: true,
              isEstimate: true,
              notes: isSafeFollicular
                  ? 'Day $cycleDay - Follicular phase (safe for 24h)'
                  : 'Day $cycleDay - Early luteal (safe for 24h)',
            ));
          }
          // If not safe but is preferred day, use shorter 14h fast
          else if (cycleDay >= 12 && cycleDay <= 14) {
            // Ovulation window - use 14h short fast instead
            schedule.add(ScheduledFasting(
              id: '${current.millisecondsSinceEpoch}',
              date: current,
              fastType: FastingUtils.shortFast,
              isEnabled: true,
              isAutoGenerated: true,
              isEstimate: true,
              notes: 'Day $cycleDay - Ovulation window (14h short fast)',
            ));
          }
          // Late luteal or menstrual - skip or use very short fast
          // Days 1-3 or 20+ are avoided entirely
        }
      }
      current = current.add(const Duration(days: 1));
    }

    // Sort by date
    schedule.sort((a, b) => a.date.compareTo(b.date));

    await saveScheduledFastings(schedule);
    return schedule;
  }

  /// Get the cycle day for a given date
  static int? _getCycleDayForDate(DateTime date, List<DateTime> cycleStarts, int cycleLength) {
    for (int i = cycleStarts.length - 1; i >= 0; i--) {
      if (date.isAfter(cycleStarts[i]) || _isSameDay(date, cycleStarts[i])) {
        final daysSinceCycleStart = date.difference(cycleStarts[i]).inDays;
        if (daysSinceCycleStart < cycleLength) {
          return daysSinceCycleStart + 1; // Day 1 = first day of period
        }
      }
    }
    return null;
  }

  /// Check if date is within a recovery week
  static bool _isInRecoveryWeek(DateTime date, Set<DateTime> recoveryWeekStarts) {
    for (final weekStart in recoveryWeekStarts) {
      final weekEnd = weekStart.add(const Duration(days: 7));
      if ((date.isAfter(weekStart) || _isSameDay(date, weekStart)) && date.isBefore(weekEnd)) {
        return true;
      }
    }
    return false;
  }

  /// Check if two dates are the same day
  static bool _isSameDay(DateTime a, DateTime b) {
    return a.year == b.year && a.month == b.month && a.day == b.day;
  }

  /// Get human-readable name for long fast type
  static String _getLongFastName(String fastType) {
    switch (fastType) {
      case '36h monthly fast':
        return 'monthly fat burner';
      case '48h quarterly fast':
        return 'quarterly dopamine reset';
      case '3-day water fast':
        return 'biannual immune reset';
      default:
        return 'extended fast';
    }
  }

  /// Smart scheduling logic for a specific date - returns (fastType, shouldSkipPreferredDay)
  static (String, bool) _getSmartFastTypeForDate(
    DateTime date,
    bool isPreferredDay,
    bool isLongFastDay,
    List<ScheduledFasting> existingSchedule,
    int preferredDay,
    int preferredMonthlyDay, {
    bool useMenstrualScheduling = false,
  }) {
    if (isLongFastDay) {
      final month = date.month;
      String longerFastType;
      if (month == 1 || month == 9) {
        longerFastType = FastingUtils.waterFast;
      } else if (month % 3 == 1) {
        longerFastType = FastingUtils.quarterlyFast;
      } else {
        longerFastType = FastingUtils.monthlyFast;
      }

      // Check if preferred day is close (within the duration of this fast)
      final fastDuration = FastingUtils.getFastDuration(longerFastType);
      final fastEndDate = date.add(fastDuration);

      // Check if there's a preferred day within the fast duration
      DateTime checkDate = date.add(const Duration(days: 1));
      bool willCoverPreferredDay = false;

      while (checkDate.isBefore(fastEndDate)) {
        if (checkDate.weekday == preferredDay) {
          willCoverPreferredDay = true;
          break;
        }
        checkDate = checkDate.add(const Duration(days: 1));
      }

      return (longerFastType, willCoverPreferredDay);
    }

    if (isPreferredDay) {
      final daysUntilMonthlyDay = preferredMonthlyDay - date.day;
      final nextMonth = date.month == 12 ? 1 : date.month + 1;

      // Check if preferred monthly day of this month or next month is within 6 days
      bool isMonthlyDayClose = false;

      if (date.day <= preferredMonthlyDay) {
        // Monthly day is later this month
        isMonthlyDayClose = daysUntilMonthlyDay <= 6;
      } else {
        // Monthly day of next month
        final nextMonthMonthlyDay = DateTime(date.year, nextMonth, preferredMonthlyDay);
        final daysToNextMonthMonthlyDay = nextMonthMonthlyDay.difference(date).inDays;
        isMonthlyDayClose = daysToNextMonthMonthlyDay <= 6;
      }

      // If monthly day is close, check if there's already a longer fast scheduled
      if (isMonthlyDayClose) {
        final upcomingMonthlyDay = date.day <= preferredMonthlyDay
            ? DateTime(date.year, date.month, preferredMonthlyDay)
            : DateTime(date.year, nextMonth, preferredMonthlyDay);

        // Check if there's already a fast scheduled for that monthly day
        final existingMonthlyFast = existingSchedule.any((fast) =>
          fast.date.year == upcomingMonthlyDay.year &&
          fast.date.month == upcomingMonthlyDay.month &&
          fast.date.day == preferredMonthlyDay
        );

        if (existingMonthlyFast) {
          return ('', false); // Skip this preferred day, monthly fast will handle it
        }
      }

      return (FastingUtils.weeklyFast, false);
    }

    return ('', false);
  }

  /// Update a scheduled fasting
  static Future<void> updateScheduledFasting(ScheduledFasting updatedFasting) async {
    final fastings = await getScheduledFastings();
    final index = fastings.indexWhere((f) => f.id == updatedFasting.id);
    
    if (index != -1) {
      fastings[index] = updatedFasting;
      await saveScheduledFastings(fastings);
    }
  }

  /// Delete a scheduled fasting
  static Future<void> deleteScheduledFasting(String id) async {
    final fastings = await getScheduledFastings();
    fastings.removeWhere((f) => f.id == id);
    await saveScheduledFastings(fastings);
  }

  /// Add a new scheduled fasting
  static Future<void> addScheduledFasting(ScheduledFasting fasting) async {
    final fastings = await getScheduledFastings();
    fastings.add(fasting);
    fastings.sort((a, b) => a.date.compareTo(b.date));
    await saveScheduledFastings(fastings);
  }

  /// Get fastings for next 2 months + last 3 days (grace period) sorted by date
  static Future<List<ScheduledFasting>> getFastingsForNext2Months() async {
    final fastings = await getScheduledFastings();
    final now = DateTime.now();
    final threeDaysAgo = DateTime(now.year, now.month, now.day - 3);
    final endDate = DateTime(now.year, now.month + 2, now.day);

    return fastings
        .where((f) => f.date.isAfter(threeDaysAgo) && f.date.isBefore(endDate))
        .toList()
      ..sort((a, b) => a.date.compareTo(b.date));
  }

  /// Clear all auto-generated fastings and regenerate with fixed logic
  static Future<void> regenerateSchedule() async {
    final fastings = await getScheduledFastings();
    
    // Keep only manually created fastings
    final manualFastings = fastings.where((f) => !f.isAutoGenerated).toList();
    
    // Save only manual fastings
    await saveScheduledFastings(manualFastings);
    
    // Generate new auto-schedule
    await generateDefaultSchedule();
  }
}

class ScheduledFasting {
  final String id;
  final DateTime date;
  final String fastType;
  final bool isEnabled;
  final bool isAutoGenerated;
  final bool isEstimate; // True for menstrual-based scheduling (dates are estimated)
  final String? notes;

  ScheduledFasting({
    required this.id,
    required this.date,
    required this.fastType,
    this.isEnabled = true,
    this.isAutoGenerated = false,
    this.isEstimate = false,
    this.notes,
  });

  ScheduledFasting copyWith({
    String? id,
    DateTime? date,
    String? fastType,
    bool? isEnabled,
    bool? isAutoGenerated,
    bool? isEstimate,
    String? notes,
  }) {
    return ScheduledFasting(
      id: id ?? this.id,
      date: date ?? this.date,
      fastType: fastType ?? this.fastType,
      isEnabled: isEnabled ?? this.isEnabled,
      isAutoGenerated: isAutoGenerated ?? this.isAutoGenerated,
      isEstimate: isEstimate ?? this.isEstimate,
      notes: notes ?? this.notes,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'date': date.toIso8601String(),
      'fastType': fastType,
      'isEnabled': isEnabled,
      'isAutoGenerated': isAutoGenerated,
      'isEstimate': isEstimate,
      'notes': notes,
    };
  }

  factory ScheduledFasting.fromJson(Map<String, dynamic> json) {
    return ScheduledFasting(
      id: json['id'],
      date: DateTime.parse(json['date']),
      fastType: json['fastType'],
      isEnabled: json['isEnabled'] ?? true,
      isAutoGenerated: json['isAutoGenerated'] ?? false,
      isEstimate: json['isEstimate'] ?? false,
      notes: json['notes'],
    );
  }

  Duration get duration => FastingUtils.getFastDuration(fastType);

  String get formattedDate {
    final months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    final weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    
    return '${weekdays[date.weekday - 1]}, ${date.day} ${months[date.month - 1]}';
  }

  String get shortFastType {
    switch (fastType) {
      case '24h weekly fast':
        return '24h';
      case '36h monthly fast':
        return '36h';
      case '48h quarterly fast':
        return '48h';
      case '3-day water fast':
        return '3-Day';
      // Cycle-adapted short fast
      case '14h short fast':
        return '14h';
      default:
        return fastType;
    }
  }
}
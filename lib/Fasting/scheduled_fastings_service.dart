import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'fasting_utils.dart';
import '../Services/firebase_backup_service.dart';

class ScheduledFastingsService {
  static const String _scheduledFastingsKey = 'scheduled_fastings';

  // Phase day offsets from period start (based on standard 28-day cycle)
  static const Map<String, int> _phaseStartDays = {
    'Menstrual Phase': 0,      // Days 1-5
    'Follicular Phase': 5,     // Days 6-11
    'Ovulation Window': 11,    // Days 12-16
    'Early Luteal Phase': 16,  // Days 17-21
    'Late Luteal Phase': 21,   // Days 22-28
  };

  /// Get all scheduled fastings
  static Future<List<ScheduledFasting>> getScheduledFastings() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_scheduledFastingsKey);
    
    if (jsonString == null) {
      // Generate default schedule for next 2 months
      return await generateDefaultSchedule();
    }

    final List<dynamic> jsonList = jsonDecode(jsonString);
    return jsonList.map((json) => ScheduledFasting.fromJson(json)).toList();
  }

  /// Save scheduled fastings
  static Future<void> saveScheduledFastings(List<ScheduledFasting> fastings) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = jsonEncode(fastings.map((f) => f.toJson()).toList());
    await prefs.setString(_scheduledFastingsKey, jsonString);

    // Backup to Firebase
    FirebaseBackupService.triggerBackup();
  }

  /// Generate default schedule based on preferred day and scheduling mode (fixed day or menstrual)
  static Future<List<ScheduledFasting>> generateDefaultSchedule() async {
    final List<ScheduledFasting> schedule = [];
    final now = DateTime.now();
    final endDate = DateTime(now.year, now.month + 2, now.day);

    // Get preferred fasting days from settings
    final prefs = await SharedPreferences.getInstance();
    final preferredDay = prefs.getInt('preferred_fasting_day') ?? 5; // Default to Friday
    final preferredMonthlyDay = prefs.getInt('preferred_monthly_fasting_day') ?? 25; // Default to 25th
    final useMenstrualScheduling = prefs.getBool('fasting_use_menstrual_scheduling') ?? false;
    final menstrualPhase = prefs.getString('fasting_menstrual_phase') ?? 'Late Luteal Phase';
    final menstrualPhaseDay = prefs.getInt('fasting_menstrual_phase_day') ?? 1;

    DateTime current = DateTime(now.year, now.month, now.day - 3); // Start from 3 days ago for grace period
    DateTime? lastFastEnd; // Track when the last fast ends

    // For menstrual scheduling, calculate long fast dates based on cycle
    List<DateTime> menstrualLongFastDates = [];
    if (useMenstrualScheduling) {
      menstrualLongFastDates = await _calculateMenstrualLongFastDates(
        now, endDate, menstrualPhase, menstrualPhaseDay,
      );
    }

    while (current.isBefore(endDate)) {
      final isPreferredDay = current.weekday == preferredDay;

      // For long fasts: either fixed day or menstrual-based
      bool isLongFastDay;
      if (useMenstrualScheduling) {
        isLongFastDay = menstrualLongFastDates.any((d) =>
          d.year == current.year && d.month == current.month && d.day == current.day
        );
      } else {
        isLongFastDay = current.day == preferredMonthlyDay;
      }

      if (isPreferredDay || isLongFastDay) {
        // Check if we need to skip this date due to ongoing fast
        if (lastFastEnd != null && current.isBefore(lastFastEnd)) {
          current = current.add(const Duration(days: 1));
          continue; // Skip this date as we're still in a previous fast
        }

        final (fastType, shouldSkipPreferredDay) = _getSmartFastTypeForDate(
          current, isPreferredDay, isLongFastDay, schedule, preferredDay, preferredMonthlyDay,
          useMenstrualScheduling: useMenstrualScheduling,
        );

        if (fastType.isNotEmpty) {
          final newFast = ScheduledFasting(
            id: '${current.millisecondsSinceEpoch}',
            date: current,
            fastType: fastType,
            isEnabled: true,
            isAutoGenerated: true,
            isEstimate: useMenstrualScheduling && isLongFastDay && !isPreferredDay,
          );

          schedule.add(newFast);

          // Update lastFastEnd to prevent overlaps
          lastFastEnd = current.add(newFast.duration);

          // If we scheduled a long fast that covers preferred day, mark it to skip preferred day
          if (isLongFastDay && shouldSkipPreferredDay) {
            // Find and remove any preferred day fast that would overlap
            schedule.removeWhere((fast) =>
              fast.date.isAfter(current) &&
              fast.date.isBefore(lastFastEnd!) &&
              fast.date.weekday == preferredDay
            );
          }
        }
      }

      current = current.add(const Duration(days: 1));
    }

    await saveScheduledFastings(schedule);
    return schedule;
  }

  /// Calculate long fast dates based on menstrual cycle
  static Future<List<DateTime>> _calculateMenstrualLongFastDates(
    DateTime startDate,
    DateTime endDate,
    String phase,
    int phaseDay,
  ) async {
    final List<DateTime> dates = [];
    final prefs = await SharedPreferences.getInstance();

    // Get last period start and average cycle length
    final lastPeriodStartStr = prefs.getString('last_period_start');
    final averageCycleLength = prefs.getInt('average_cycle_length') ?? 28;

    if (lastPeriodStartStr == null) {
      // No period data - fall back to estimating based on current date
      return dates;
    }

    final lastPeriodStart = DateTime.parse(lastPeriodStartStr);
    final phaseOffset = _phaseStartDays[phase] ?? 0;

    // Calculate the day within the cycle for the long fast
    // phaseDay is 1-indexed (Day 1, Day 2, etc.)
    final dayInCycle = phaseOffset + phaseDay; // e.g., Late Luteal (21) + Day 1 = Day 22

    // Find periods that fall within our date range
    DateTime periodStart = lastPeriodStart;

    // Go back a few cycles to catch any that might fall in our range
    while (periodStart.isAfter(startDate.subtract(Duration(days: averageCycleLength)))) {
      periodStart = periodStart.subtract(Duration(days: averageCycleLength));
    }

    // Now iterate forward through cycles
    while (periodStart.isBefore(endDate)) {
      // Calculate the long fast date for this cycle
      final longFastDate = periodStart.add(Duration(days: dayInCycle - 1)); // -1 because day 1 = 0 offset

      if (longFastDate.isAfter(startDate.subtract(const Duration(days: 4))) &&
          longFastDate.isBefore(endDate)) {
        dates.add(DateTime(longFastDate.year, longFastDate.month, longFastDate.day));
      }

      // Move to next cycle
      periodStart = periodStart.add(Duration(days: averageCycleLength));
    }

    return dates;
  }

  /// Smart scheduling logic for a specific date - returns (fastType, shouldSkipPreferredDay)
  static (String, bool) _getSmartFastTypeForDate(
    DateTime date,
    bool isPreferredDay,
    bool isLongFastDay,
    List<ScheduledFasting> existingSchedule,
    int preferredDay,
    int preferredMonthlyDay, {
    bool useMenstrualScheduling = false,
  }) {
    if (isLongFastDay) {
      final month = date.month;
      String longerFastType;
      if (month == 1 || month == 9) {
        longerFastType = FastingUtils.waterFast;
      } else if (month % 3 == 1) {
        longerFastType = FastingUtils.quarterlyFast;
      } else {
        longerFastType = FastingUtils.monthlyFast;
      }

      // Check if preferred day is close (within the duration of this fast)
      final fastDuration = FastingUtils.getFastDuration(longerFastType);
      final fastEndDate = date.add(fastDuration);

      // Check if there's a preferred day within the fast duration
      DateTime checkDate = date.add(const Duration(days: 1));
      bool willCoverPreferredDay = false;

      while (checkDate.isBefore(fastEndDate)) {
        if (checkDate.weekday == preferredDay) {
          willCoverPreferredDay = true;
          break;
        }
        checkDate = checkDate.add(const Duration(days: 1));
      }

      return (longerFastType, willCoverPreferredDay);
    }

    if (isPreferredDay) {
      final daysUntilMonthlyDay = preferredMonthlyDay - date.day;
      final nextMonth = date.month == 12 ? 1 : date.month + 1;

      // Check if preferred monthly day of this month or next month is within 6 days
      bool isMonthlyDayClose = false;

      if (date.day <= preferredMonthlyDay) {
        // Monthly day is later this month
        isMonthlyDayClose = daysUntilMonthlyDay <= 6;
      } else {
        // Monthly day of next month
        final nextMonthMonthlyDay = DateTime(date.year, nextMonth, preferredMonthlyDay);
        final daysToNextMonthMonthlyDay = nextMonthMonthlyDay.difference(date).inDays;
        isMonthlyDayClose = daysToNextMonthMonthlyDay <= 6;
      }

      // If monthly day is close, check if there's already a longer fast scheduled
      if (isMonthlyDayClose) {
        final upcomingMonthlyDay = date.day <= preferredMonthlyDay
            ? DateTime(date.year, date.month, preferredMonthlyDay)
            : DateTime(date.year, nextMonth, preferredMonthlyDay);

        // Check if there's already a fast scheduled for that monthly day
        final existingMonthlyFast = existingSchedule.any((fast) =>
          fast.date.year == upcomingMonthlyDay.year &&
          fast.date.month == upcomingMonthlyDay.month &&
          fast.date.day == preferredMonthlyDay
        );

        if (existingMonthlyFast) {
          return ('', false); // Skip this preferred day, monthly fast will handle it
        }
      }

      return (FastingUtils.weeklyFast, false);
    }

    return ('', false);
  }

  /// Update a scheduled fasting
  static Future<void> updateScheduledFasting(ScheduledFasting updatedFasting) async {
    final fastings = await getScheduledFastings();
    final index = fastings.indexWhere((f) => f.id == updatedFasting.id);
    
    if (index != -1) {
      fastings[index] = updatedFasting;
      await saveScheduledFastings(fastings);
    }
  }

  /// Delete a scheduled fasting
  static Future<void> deleteScheduledFasting(String id) async {
    final fastings = await getScheduledFastings();
    fastings.removeWhere((f) => f.id == id);
    await saveScheduledFastings(fastings);
  }

  /// Add a new scheduled fasting
  static Future<void> addScheduledFasting(ScheduledFasting fasting) async {
    final fastings = await getScheduledFastings();
    fastings.add(fasting);
    fastings.sort((a, b) => a.date.compareTo(b.date));
    await saveScheduledFastings(fastings);
  }

  /// Get fastings for next 2 months + last 3 days (grace period) sorted by date
  static Future<List<ScheduledFasting>> getFastingsForNext2Months() async {
    final fastings = await getScheduledFastings();
    final now = DateTime.now();
    final threeDaysAgo = DateTime(now.year, now.month, now.day - 3);
    final endDate = DateTime(now.year, now.month + 2, now.day);

    return fastings
        .where((f) => f.date.isAfter(threeDaysAgo) && f.date.isBefore(endDate))
        .toList()
      ..sort((a, b) => a.date.compareTo(b.date));
  }

  /// Clear all auto-generated fastings and regenerate with fixed logic
  static Future<void> regenerateSchedule() async {
    final fastings = await getScheduledFastings();
    
    // Keep only manually created fastings
    final manualFastings = fastings.where((f) => !f.isAutoGenerated).toList();
    
    // Save only manual fastings
    await saveScheduledFastings(manualFastings);
    
    // Generate new auto-schedule
    await generateDefaultSchedule();
  }
}

class ScheduledFasting {
  final String id;
  final DateTime date;
  final String fastType;
  final bool isEnabled;
  final bool isAutoGenerated;
  final bool isEstimate; // True for menstrual-based scheduling (dates are estimated)
  final String? notes;

  ScheduledFasting({
    required this.id,
    required this.date,
    required this.fastType,
    this.isEnabled = true,
    this.isAutoGenerated = false,
    this.isEstimate = false,
    this.notes,
  });

  ScheduledFasting copyWith({
    String? id,
    DateTime? date,
    String? fastType,
    bool? isEnabled,
    bool? isAutoGenerated,
    bool? isEstimate,
    String? notes,
  }) {
    return ScheduledFasting(
      id: id ?? this.id,
      date: date ?? this.date,
      fastType: fastType ?? this.fastType,
      isEnabled: isEnabled ?? this.isEnabled,
      isAutoGenerated: isAutoGenerated ?? this.isAutoGenerated,
      isEstimate: isEstimate ?? this.isEstimate,
      notes: notes ?? this.notes,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'date': date.toIso8601String(),
      'fastType': fastType,
      'isEnabled': isEnabled,
      'isAutoGenerated': isAutoGenerated,
      'isEstimate': isEstimate,
      'notes': notes,
    };
  }

  factory ScheduledFasting.fromJson(Map<String, dynamic> json) {
    return ScheduledFasting(
      id: json['id'],
      date: DateTime.parse(json['date']),
      fastType: json['fastType'],
      isEnabled: json['isEnabled'] ?? true,
      isAutoGenerated: json['isAutoGenerated'] ?? false,
      isEstimate: json['isEstimate'] ?? false,
      notes: json['notes'],
    );
  }

  Duration get duration => FastingUtils.getFastDuration(fastType);

  String get formattedDate {
    final months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    final weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    
    return '${weekdays[date.weekday - 1]}, ${date.day} ${months[date.month - 1]}';
  }

  String get shortFastType {
    switch (fastType) {
      case '24h weekly fast':
        return '24h';
      case '36h monthly fast':
        return '36h';
      case '48h quarterly fast':
        return '48h';
      case '3-day water fast':
        return '3-Day';
      default:
        return fastType;
    }
  }
}
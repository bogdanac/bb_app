import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'fasting_utils.dart';

class ScheduledFastingsService {
  static const String _scheduledFastingsKey = 'scheduled_fastings';

  /// Get all scheduled fastings
  static Future<List<ScheduledFasting>> getScheduledFastings() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_scheduledFastingsKey);
    
    if (jsonString == null) {
      // Generate default schedule for next 2 months
      return await generateDefaultSchedule();
    }

    final List<dynamic> jsonList = jsonDecode(jsonString);
    return jsonList.map((json) => ScheduledFasting.fromJson(json)).toList();
  }

  /// Save scheduled fastings
  static Future<void> saveScheduledFastings(List<ScheduledFasting> fastings) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = jsonEncode(fastings.map((f) => f.toJson()).toList());
    await prefs.setString(_scheduledFastingsKey, jsonString);
  }

  /// Generate default schedule based on preferred day and 25th with overlap prevention
  static Future<List<ScheduledFasting>> generateDefaultSchedule() async {
    final List<ScheduledFasting> schedule = [];
    final now = DateTime.now();
    final endDate = DateTime(now.year, now.month + 2, now.day);

    // Get preferred fasting days from settings
    final prefs = await SharedPreferences.getInstance();
    final preferredDay = prefs.getInt('preferred_fasting_day') ?? 5; // Default to Friday
    final preferredMonthlyDay = prefs.getInt('preferred_monthly_fasting_day') ?? 25; // Default to 25th

    DateTime current = DateTime(now.year, now.month, now.day - 3); // Start from 3 days ago for grace period
    DateTime? lastFastEnd; // Track when the last fast ends

    while (current.isBefore(endDate)) {
      final isPreferredDay = current.weekday == preferredDay;
      final isPreferredMonthlyDay = current.day == preferredMonthlyDay;

      if (isPreferredDay || isPreferredMonthlyDay) {
        // Check if we need to skip this date due to ongoing fast
        if (lastFastEnd != null && current.isBefore(lastFastEnd)) {
          current = current.add(const Duration(days: 1));
          continue; // Skip this date as we're still in a previous fast
        }

        final (fastType, shouldSkipPreferredDay) = _getSmartFastTypeForDate(current, isPreferredDay, isPreferredMonthlyDay, schedule, preferredDay, preferredMonthlyDay);
        
        if (fastType.isNotEmpty) {
          final newFast = ScheduledFasting(
            id: '${current.millisecondsSinceEpoch}',
            date: current,
            fastType: fastType,
            isEnabled: true,
            isAutoGenerated: true,
          );
          
          schedule.add(newFast);
          
          // Update lastFastEnd to prevent overlaps
          lastFastEnd = current.add(newFast.duration);
          
          // If we scheduled a long fast on monthly day that covers preferred day, mark it to skip preferred day
          if (isPreferredMonthlyDay && shouldSkipPreferredDay) {
            // Find and remove any preferred day fast that would overlap
            schedule.removeWhere((fast) =>
              fast.date.isAfter(current) &&
              fast.date.isBefore(lastFastEnd!) &&
              fast.date.weekday == preferredDay
            );
          }
        }
      }

      current = current.add(const Duration(days: 1));
    }

    await saveScheduledFastings(schedule);
    return schedule;
  }

  /// Smart scheduling logic for a specific date - returns (fastType, shouldSkipPreferredDay)
  static (String, bool) _getSmartFastTypeForDate(DateTime date, bool isPreferredDay, bool isPreferredMonthlyDay, List<ScheduledFasting> existingSchedule, int preferredDay, int preferredMonthlyDay) {
    if (isPreferredMonthlyDay) {
      final month = date.month;
      String longerFastType;
      if (month == 1 || month == 9) {
        longerFastType = FastingUtils.waterFast;
      } else if (month % 3 == 1) {
        longerFastType = FastingUtils.quarterlyFast;
      } else {
        longerFastType = FastingUtils.monthlyFast;
      }

      // Check if preferred day is close (within the duration of this fast)
      final fastDuration = FastingUtils.getFastDuration(longerFastType);
      final fastEndDate = date.add(fastDuration);

      // Check if there's a preferred day within the fast duration
      DateTime checkDate = date.add(const Duration(days: 1));
      bool willCoverPreferredDay = false;

      while (checkDate.isBefore(fastEndDate)) {
        if (checkDate.weekday == preferredDay) {
          willCoverPreferredDay = true;
          break;
        }
        checkDate = checkDate.add(const Duration(days: 1));
      }

      return (longerFastType, willCoverPreferredDay);
    }

    if (isPreferredDay) {
      final daysUntilMonthlyDay = preferredMonthlyDay - date.day;
      final nextMonth = date.month == 12 ? 1 : date.month + 1;

      // Check if preferred monthly day of this month or next month is within 6 days
      bool isMonthlyDayClose = false;

      if (date.day <= preferredMonthlyDay) {
        // Monthly day is later this month
        isMonthlyDayClose = daysUntilMonthlyDay <= 6;
      } else {
        // Monthly day of next month
        final nextMonthMonthlyDay = DateTime(date.year, nextMonth, preferredMonthlyDay);
        final daysToNextMonthMonthlyDay = nextMonthMonthlyDay.difference(date).inDays;
        isMonthlyDayClose = daysToNextMonthMonthlyDay <= 6;
      }

      // If monthly day is close, check if there's already a longer fast scheduled
      if (isMonthlyDayClose) {
        final upcomingMonthlyDay = date.day <= preferredMonthlyDay
            ? DateTime(date.year, date.month, preferredMonthlyDay)
            : DateTime(date.year, nextMonth, preferredMonthlyDay);

        // Check if there's already a fast scheduled for that monthly day
        final existingMonthlyFast = existingSchedule.any((fast) =>
          fast.date.year == upcomingMonthlyDay.year &&
          fast.date.month == upcomingMonthlyDay.month &&
          fast.date.day == preferredMonthlyDay
        );

        if (existingMonthlyFast) {
          return ('', false); // Skip this preferred day, monthly fast will handle it
        }
      }

      return (FastingUtils.weeklyFast, false);
    }

    return ('', false);
  }

  /// Update a scheduled fasting
  static Future<void> updateScheduledFasting(ScheduledFasting updatedFasting) async {
    final fastings = await getScheduledFastings();
    final index = fastings.indexWhere((f) => f.id == updatedFasting.id);
    
    if (index != -1) {
      fastings[index] = updatedFasting;
      await saveScheduledFastings(fastings);
    }
  }

  /// Delete a scheduled fasting
  static Future<void> deleteScheduledFasting(String id) async {
    final fastings = await getScheduledFastings();
    fastings.removeWhere((f) => f.id == id);
    await saveScheduledFastings(fastings);
  }

  /// Add a new scheduled fasting
  static Future<void> addScheduledFasting(ScheduledFasting fasting) async {
    final fastings = await getScheduledFastings();
    fastings.add(fasting);
    fastings.sort((a, b) => a.date.compareTo(b.date));
    await saveScheduledFastings(fastings);
  }

  /// Get fastings for next 2 months + last 3 days (grace period) sorted by date
  static Future<List<ScheduledFasting>> getFastingsForNext2Months() async {
    final fastings = await getScheduledFastings();
    final now = DateTime.now();
    final threeDaysAgo = DateTime(now.year, now.month, now.day - 3);
    final endDate = DateTime(now.year, now.month + 2, now.day);

    return fastings
        .where((f) => f.date.isAfter(threeDaysAgo) && f.date.isBefore(endDate))
        .toList()
      ..sort((a, b) => a.date.compareTo(b.date));
  }

  /// Clear all auto-generated fastings and regenerate with fixed logic
  static Future<void> regenerateSchedule() async {
    final fastings = await getScheduledFastings();
    
    // Keep only manually created fastings
    final manualFastings = fastings.where((f) => !f.isAutoGenerated).toList();
    
    // Save only manual fastings
    await saveScheduledFastings(manualFastings);
    
    // Generate new auto-schedule
    await generateDefaultSchedule();
  }
}

class ScheduledFasting {
  final String id;
  final DateTime date;
  final String fastType;
  final bool isEnabled;
  final bool isAutoGenerated;
  final String? notes;

  ScheduledFasting({
    required this.id,
    required this.date,
    required this.fastType,
    this.isEnabled = true,
    this.isAutoGenerated = false,
    this.notes,
  });

  ScheduledFasting copyWith({
    String? id,
    DateTime? date,
    String? fastType,
    bool? isEnabled,
    bool? isAutoGenerated,
    String? notes,
  }) {
    return ScheduledFasting(
      id: id ?? this.id,
      date: date ?? this.date,
      fastType: fastType ?? this.fastType,
      isEnabled: isEnabled ?? this.isEnabled,
      isAutoGenerated: isAutoGenerated ?? this.isAutoGenerated,
      notes: notes ?? this.notes,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'date': date.toIso8601String(),
      'fastType': fastType,
      'isEnabled': isEnabled,
      'isAutoGenerated': isAutoGenerated,
      'notes': notes,
    };
  }

  factory ScheduledFasting.fromJson(Map<String, dynamic> json) {
    return ScheduledFasting(
      id: json['id'],
      date: DateTime.parse(json['date']),
      fastType: json['fastType'],
      isEnabled: json['isEnabled'] ?? true,
      isAutoGenerated: json['isAutoGenerated'] ?? false,
      notes: json['notes'],
    );
  }

  Duration get duration => FastingUtils.getFastDuration(fastType);

  String get formattedDate {
    final months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    final weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    
    return '${weekdays[date.weekday - 1]}, ${date.day} ${months[date.month - 1]}';
  }

  String get shortFastType {
    switch (fastType) {
      case '24h weekly fast':
        return '24h';
      case '36h monthly fast':
        return '36h';
      case '48h quarterly fast':
        return '48h';
      case '3-day water fast':
        return '3-Day';
      default:
        return fastType;
    }
  }
}
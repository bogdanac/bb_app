import 'package:shared_preferences/shared_preferences.dart';
import 'dart:convert';
import 'fasting_utils.dart';

class ScheduledFastingsService {
  static const String _scheduledFastingsKey = 'scheduled_fastings';

  /// Get all scheduled fastings
  static Future<List<ScheduledFasting>> getScheduledFastings() async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = prefs.getString(_scheduledFastingsKey);
    
    if (jsonString == null) {
      // Generate default schedule for next 2 months
      return await generateDefaultSchedule();
    }

    final List<dynamic> jsonList = jsonDecode(jsonString);
    return jsonList.map((json) => ScheduledFasting.fromJson(json)).toList();
  }

  /// Save scheduled fastings
  static Future<void> saveScheduledFastings(List<ScheduledFasting> fastings) async {
    final prefs = await SharedPreferences.getInstance();
    final jsonString = jsonEncode(fastings.map((f) => f.toJson()).toList());
    await prefs.setString(_scheduledFastingsKey, jsonString);
  }

  /// Generate default schedule based on current logic (Fridays and 25th) with overlap prevention
  static Future<List<ScheduledFasting>> generateDefaultSchedule() async {
    final List<ScheduledFasting> schedule = [];
    final now = DateTime.now();
    final endDate = DateTime(now.year, now.month + 2, now.day);

    DateTime current = DateTime(now.year, now.month, now.day - 3); // Start from 3 days ago for grace period
    DateTime? lastFastEnd; // Track when the last fast ends

    while (current.isBefore(endDate)) {
      final isFriday = current.weekday == 5;
      final is25th = current.day == 25;

      if (isFriday || is25th) {
        // Check if we need to skip this date due to ongoing fast
        if (lastFastEnd != null && current.isBefore(lastFastEnd)) {
          current = current.add(const Duration(days: 1));
          continue; // Skip this date as we're still in a previous fast
        }

        final (fastType, shouldSkipFriday) = _getSmartFastTypeForDate(current, isFriday, is25th, schedule);
        
        if (fastType.isNotEmpty) {
          final newFast = ScheduledFasting(
            id: '${current.millisecondsSinceEpoch}',
            date: current,
            fastType: fastType,
            isEnabled: true,
            isAutoGenerated: true,
          );
          
          schedule.add(newFast);
          
          // Update lastFastEnd to prevent overlaps
          lastFastEnd = current.add(newFast.duration);
          
          // If we scheduled a long fast on 25th that covers Friday, mark it to skip Friday
          if (is25th && shouldSkipFriday) {
            // Find and remove any Friday fast that would overlap
            schedule.removeWhere((fast) => 
              fast.date.isAfter(current) && 
              fast.date.isBefore(lastFastEnd!) &&
              fast.date.weekday == 5
            );
          }
        }
      }

      current = current.add(const Duration(days: 1));
    }

    await saveScheduledFastings(schedule);
    return schedule;
  }

  /// Smart scheduling logic for a specific date - returns (fastType, shouldSkipFriday)
  static (String, bool) _getSmartFastTypeForDate(DateTime date, bool isFriday, bool is25th, List<ScheduledFasting> existingSchedule) {
    if (is25th) {
      final month = date.month;
      String longerFastType;
      if (month == 1 || month == 9) {
        longerFastType = FastingUtils.waterFast;
      } else if (month % 3 == 1) {
        longerFastType = FastingUtils.quarterlyFast;
      } else {
        longerFastType = FastingUtils.monthlyFast;
      }

      // Check if Friday is close (within the duration of this fast)
      final fastDuration = FastingUtils.getFastDuration(longerFastType);
      final fastEndDate = date.add(fastDuration);
      
      // Check if there's a Friday within the fast duration
      DateTime checkDate = date.add(const Duration(days: 1));
      bool willCoverFriday = false;
      
      while (checkDate.isBefore(fastEndDate)) {
        if (checkDate.weekday == 5) { // Friday
          willCoverFriday = true;
          break;
        }
        checkDate = checkDate.add(const Duration(days: 1));
      }

      return (longerFastType, willCoverFriday);
    }

    if (isFriday) {
      final daysUntil25th = 25 - date.day;
      final nextMonth = date.month == 12 ? 1 : date.month + 1;

      // Check if 25th of this month or next month is within 6 days
      bool is25thClose = false;
      
      if (date.day <= 25) {
        // 25th of this month
        is25thClose = daysUntil25th <= 6;
      } else {
        // 25th of next month
        final nextMonth25th = DateTime(date.year, nextMonth, 25);
        final daysToNextMonth25th = nextMonth25th.difference(date).inDays;
        is25thClose = daysToNextMonth25th <= 6;
      }

      // If 25th is close, check if there's already a longer fast scheduled
      if (is25thClose) {
        final upcoming25th = date.day <= 25 
            ? DateTime(date.year, date.month, 25)
            : DateTime(date.year, nextMonth, 25);
            
        // Check if there's already a fast scheduled for that 25th
        final existing25thFast = existingSchedule.any((fast) => 
          fast.date.year == upcoming25th.year && 
          fast.date.month == upcoming25th.month && 
          fast.date.day == 25
        );
        
        if (existing25thFast) {
          return ('', false); // Skip this Friday, 25th fast will handle it
        }
      }

      return (FastingUtils.weeklyFast, false);
    }

    return ('', false);
  }

  /// Update a scheduled fasting
  static Future<void> updateScheduledFasting(ScheduledFasting updatedFasting) async {
    final fastings = await getScheduledFastings();
    final index = fastings.indexWhere((f) => f.id == updatedFasting.id);
    
    if (index != -1) {
      fastings[index] = updatedFasting;
      await saveScheduledFastings(fastings);
    }
  }

  /// Delete a scheduled fasting
  static Future<void> deleteScheduledFasting(String id) async {
    final fastings = await getScheduledFastings();
    fastings.removeWhere((f) => f.id == id);
    await saveScheduledFastings(fastings);
  }

  /// Add a new scheduled fasting
  static Future<void> addScheduledFasting(ScheduledFasting fasting) async {
    final fastings = await getScheduledFastings();
    fastings.add(fasting);
    fastings.sort((a, b) => a.date.compareTo(b.date));
    await saveScheduledFastings(fastings);
  }

  /// Get fastings for next 2 months + last 3 days (grace period) sorted by date
  static Future<List<ScheduledFasting>> getFastingsForNext2Months() async {
    final fastings = await getScheduledFastings();
    final now = DateTime.now();
    final threeDaysAgo = DateTime(now.year, now.month, now.day - 3);
    final endDate = DateTime(now.year, now.month + 2, now.day);

    return fastings
        .where((f) => f.date.isAfter(threeDaysAgo) && f.date.isBefore(endDate))
        .toList()
      ..sort((a, b) => a.date.compareTo(b.date));
  }

  /// Clear all auto-generated fastings and regenerate with fixed logic
  static Future<void> regenerateSchedule() async {
    final fastings = await getScheduledFastings();
    
    // Keep only manually created fastings
    final manualFastings = fastings.where((f) => !f.isAutoGenerated).toList();
    
    // Save only manual fastings
    await saveScheduledFastings(manualFastings);
    
    // Generate new auto-schedule
    await generateDefaultSchedule();
  }
}

class ScheduledFasting {
  final String id;
  final DateTime date;
  final String fastType;
  final bool isEnabled;
  final bool isAutoGenerated;
  final String? notes;

  ScheduledFasting({
    required this.id,
    required this.date,
    required this.fastType,
    this.isEnabled = true,
    this.isAutoGenerated = false,
    this.notes,
  });

  ScheduledFasting copyWith({
    String? id,
    DateTime? date,
    String? fastType,
    bool? isEnabled,
    bool? isAutoGenerated,
    String? notes,
  }) {
    return ScheduledFasting(
      id: id ?? this.id,
      date: date ?? this.date,
      fastType: fastType ?? this.fastType,
      isEnabled: isEnabled ?? this.isEnabled,
      isAutoGenerated: isAutoGenerated ?? this.isAutoGenerated,
      notes: notes ?? this.notes,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'date': date.toIso8601String(),
      'fastType': fastType,
      'isEnabled': isEnabled,
      'isAutoGenerated': isAutoGenerated,
      'notes': notes,
    };
  }

  factory ScheduledFasting.fromJson(Map<String, dynamic> json) {
    return ScheduledFasting(
      id: json['id'],
      date: DateTime.parse(json['date']),
      fastType: json['fastType'],
      isEnabled: json['isEnabled'] ?? true,
      isAutoGenerated: json['isAutoGenerated'] ?? false,
      notes: json['notes'],
    );
  }

  Duration get duration => FastingUtils.getFastDuration(fastType);

  String get formattedDate {
    final months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                   'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
    final weekdays = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
    
    return '${weekdays[date.weekday - 1]}, ${date.day} ${months[date.month - 1]}';
  }

  String get shortFastType {
    switch (fastType) {
      case '24h weekly fast':
        return '24h';
      case '36h monthly fast':
        return '36h';
      case '48h quarterly fast':
        return '48h';
      case '3-day water fast':
        return '3-Day';
      default:
        return fastType;
    }
  }
}